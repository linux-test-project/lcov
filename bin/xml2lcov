#!/usr/bin/env python3

#   Copyright (c) MediaTek USA Inc., 2020-2024
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, see
#   <http://www.gnu.org/licenses/>.
#
#
# This script traverses Python coverage data in one or more coverage
# data file (generated by the Coverage.py module) and translates it into
# LCOV .info format.
#
#   xml2lcov [--output mydata.info] [--test-name name] [options] coverage.xml+
#
# See 'xml2lcov --help' for more usage information
#
# See the Cobertura documentation to see how to generate the XML coverage data

import os
import os.path
import sys
import re
import argparse
import xml.etree.ElementTree as ET
import fnmatch
import subprocess
import copy
import base64
import hashlib
import pdb
from xml2lcovutil import ProcessFile

def main():
    usageString="""xml2lcov: Translate XML coverage data (e.g., generated by Cobertura)
to LCOV .info format.
See the Cobertura documentation for information on how to generate the
XML coverage data file.

Note that xml2lcov does not implement the full suite of LCOV features
(e.g., demangling, filtering, substitutions, etc.).
Please generate the translated LCOV format file and then read the data
back in to lcov to use any of those features.
%(usage)s
Example:

     # generate the LCOV-format .info file
   $ xml2lcov -o mydata.info coverage1.xml coverage2.xml

     # apply some filtering
   $ lcov -a mydata.info --filter branch,blank -o filtered.info

     # and use genhtml to produce an HTML coverage report:
   $ genhtml -o html_report mydata.info ....
   $ genhtml -o html_filtered filtered.info ....
     # use differential coverage to see exactly what filtering did
   $ genhtml -o html_differential --baseline-file mydata.info filtered.info ...

   """ % {
       'usage' : ProcessFile.usageNote,
       }

    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=usageString)

    parser.add_argument('-o', '--output', dest='output', default='xml2lcov.info',
                        help="specify the out LCOV .info file, default: xml2lcov.info")
    parser.add_argument('-t', '--test-name', '--testname', dest='testName', default='',
                        help="specify the test name for the TN: entry in LCOV .info file")
    parser.add_argument('-e', '--exclude', dest='excludePatterns', default='',
                        help="specify the exclude file patterns separated by ','")
    parser.add_argument('-v', '--verbose', dest='verbose', default=0, action='count',
                        help="print debug messages")
    parser.add_argument('--version-script', dest='version',
                        help="version extract callback")
    parser.add_argument('--checksum', dest='checksum', action='store_true',
                        default=False,
                        help="compute line checksum - see 'man lcov'")
    parser.add_argument('-k', "--keep-going", dest='keepGoing', default=False, action='store_true',
                        help="ignore errors")
    parser.add_argument('inputs', nargs='*',
                        help="list of python coverage data input files - expected to be XML or Python .dat format")

    args = parser.parse_args()

    if not args.inputs:
       print("Error:  no input files")
       sys.exit(1)

    p = ProcessFile(args)

    for f in args.inputs:
        p.process_xml_file(f)

    p.close()


if __name__ == '__main__':
    main()
